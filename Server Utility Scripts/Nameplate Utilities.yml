#A set of procedures designed to manipulate nameplates
#todo: Use math to figure out what option the player is really looking at to make a better feel.


Display Defaults:
    type: world
    events:
        #on display created in <cuboids>:
        #on display created in <cuboids> owned by <owner>:
        #on display titled <title>:
        #on display titled <title> in <cuboids>:
        on player right clicks entity:
        - announce "[<script.name>] player clicked <context.entity.name||<context.entity.entity_type>>"
        
        on player right clicks:
        - announce "[<script.name>] player clicked at <player.target.name||<player.target.entity_type||no_target>>"
        
        
        on display creation:
        
        #on display titled <title> in <cuboids>:
        #<context.entitys>
        #<context.location>
        #<context.calling_script>
        #<context.removal_method>
        
        #keep all displays stored in a display list and check if  they have a removal method, 
        #   if not remove them maybe on shutdown or creation?
        on player opens context menu:
        #- announce "opens context menu"
        on player opens title menu:
        #- announce "opens title menu"
        
        #on player opens <context> menu:
        #- announce "opens named context: <context.context> menu"
        #on player opens <title> menu:
        #- announce "opens named title: <context.title> menu"
        
        # on player selects option in context menu:
        # on player selects option in title menu:
        # on player selects option in <context> menu:
        # on player selects option in <title> menu:
        
        # on player selects <option> in context menu:
        # on player selects <option> in title menu:
        # on player selects <option> in <context> menu:
        # on player selects <option> in <title> menu:
        
        # on player selects <option> in context menu:
        # on player selects <option> in <context> menu:



Determine Max Possible Display Height:
    #############################################################################################################################
    #                                                                                                                           #
    # procedure for figuring out selection indexes                                                                              #
    #                                                                                                                           #
    #############################################################################################################################
    #todo: Calibrate the setting for accuracy at long and short distances.
    type: procedure
    definitions: num_plates
    script:
    - determine <def[num_plates].mul[.5]>
    

#todo: complete me
Update Display Line:
    #############################################################################################################################
    #                                                                                                                           #
    # A task to update a line in a display                                                                                      #
    #                                                                                                                           #
    #############################################################################################################################
    type: task
    definitions: line|text
    script:
    - define text <parse:<def[text]>>
    - define text <proc[Iconize].context[<def[text]>]>
    - adjust <def[entity]> custom_name:<def[text]>
    

#########################################################################################################################
############################# Display Handlers ##########################################################################
#########################################################################################################################

Remove Stray Display:
    type: task
    definitions: location|range
    script:
    - if <def[range]> == null define range 10
    - define target <def[location].find.entities[ArmorStand].within[<def[range]>]>
    - remove <def[target]>
    - narrate "<blue>Cleared <red><def[target].size> <blue>stray displays."


Display Base:
    #############################################################################################################################
    #                                                                                                                           #
    # This is a procedure that creates a display. You have to capture the output of it so you can remove or store               #
    # the display entites as you wish.                                                                                          #
    #                                                                                                                           #
    # When done this way that gives the scripter the power to store the entites as they desire.                                 #
    #                                                                                                                           #
    # Creates the entities and returns the entity list.                                                                         #
    # Youll need to choose how to store the entities for removal later.                                                         #
    #                                                                                                                           #
    # notice: This is a script that needs to be managed by another script.                                                      #
    #                                                                                                                           #
    #############################################################################################################################
    type: procedure
    definitions: location|text_list|title|persistant
    script:
    # Raise error if recieved bad arguments
    - if <def[location]||none> == none 
      || <def[location]||none> == null {
        - define message "<script.name> requires that a location is not null."
        - event "Script Generates Error" context:message|<def[message]>|queue|<queue>
        - queue clear
        }
    - if <def[text_list]||none> == none {
        - define message "<script.name> requires that the text list not be null. (null dose not parse with <&sq>.size<&sq>)"
        - event "Script Generates Error" context:message|<def[message]>|queue|<queue>
        - queue clear
        }
    - define persistant <def[persistant]||false>
    - if <def[persistant]> == 0
      || <def[persistant]> == ""
      || <def[persistant]> == null
      || <def[persistant]> == false
      define persistant 0
      else
      define persistant 1
    
    - if <def[title]||none> == none  define title "Context Menu"
    
    #gives other scripts a say about whats displayed
    - event "Display Creation" "context:queue|<queue>|location|<def[location]>|player|<player||<npc||none>>|text|<def[text_list]>|title|<def[title]>" save:Display
    - define event_determination <entry[Display].determinations>
    - if <def[event_determination].contains[cancelled]> queue clear
    #this will 
    - if <def[event_determination].contains[none]> define text <def[event_determination]>
    
    # The meat of the script
    - define display_entities li@
    - define text_list <def[text_list].unescaped.as_list>
    - define location <def[location].below>
    - foreach <def[text_list].reverse> {
        - define line <proc[Iconize].context[<def[value]>]>
        - define new_y <def[loop_index].mul[.25]>
        - execute as_server "summon ArmorStand <def[location].x> <def[location].y.add[<def[new_y]>]> <def[location].z> {CustomName:<def[line]>,CustomNameVisible:1,Small:1,Marker:1b,Invisible:1,NoBasePlate:1,NoGravity:1,PersistenceRequired:<def[persistant]>}"
        - define stand <def[location].add[0,<def[new_y]>,0].find.entities[Armor_Stand].within[1]>
        - define display_entities <def[display_entities].include[<def[stand]>].deduplicate>
        }
    #
    #Can I get the entities from the determination from the event script caller? <queue.script.determination>?
    #- event "Display Creation" "context:script|<queue.script>|queue|<queue>|display entities|<escape:<def[display_entities]>>|location|<def[location]>|player|<player>|<def[text]>|title|<def[title]>"
    - determine <def[display_entities].escaped>
    

Display:
    #
    # The culmulation of the display sets of scripts
    # display_time is optional as it defaults to 2 seconds
    #
    #
    type: task
    definitions: location|text|display_time
    script:
    - define display_entities "<proc[Display Base].context[<def[location]>|<def[text]>]>"
    - wait <def[display_time]||d@30t>
    - remove <def[display_entities].unescaped>
    

Server Display:
    type: task
    definitions: flag|location|text
    script:
    - define text <proc[iconize].context[<def[text]>]>
    - define text <def[text].escaped>
    - define flag displays.<def[flag]>
    - if <server.has_flag[<def[flag]>]> {
        - announce "<red>Trying to remove <server.flag[<def[flag]>].as_list.size> entities"
        - remove <server.flag[<def[flag]>].as_list>
        - flag server <def[flag]>:!
        }
    - flag server "<def[flag]>:|:<proc[Display Base].context[<def[location]>|<def[text]>].unescaped>||persistant"



Context Menu:
    type: task
    definitions: option_list|script_list|argument_list|context|title|time_out
    script:
    - ^define events "
        player opens context menu|
        player opens title menu|
        player opens <def[context]> menu|
        player opens <def[title]> menu"
    
    - ^define context "
        context<&co>
        options     |<def[option_list]>|
        scripts     |<def[script_list]>|
        arguments   |<def[argument_list]>|
        context     |<def[context]>|
        title       |<def[title]>|
        timeout     |<def[time_out]>"
    
    - ^event <def[events]> <def[context]> save:context_readjust
    - ^if <entry[context_readjust].determinations.contains[cancelled]> queue clear
    
    - ^define time_out <def[time_out]||d@10s>
    - ^define options <def[option_list].unescaped>
    - ^define scripts <def[script_list].unescaped>
    - ^define argument_list <def[argument_list].unescaped>
    - ^define num_options <def[options].size>
    
    - ^define display_location "<proc[Entity Display Location].context[<player>]>"
    - ^define displays_list "<proc[Display Base].context[<def[display_location]>|<def[option_list]>]>"
    - run "Context Menu Display Timeout" def:<def[displays_list]> delay:<def[time_out]> id:<player.name>_display_timeout
    - queue pause
    - queue queue:q@<player.name>_display_timeout stop
    - ^remove <def[displays_list].unescaped>
    - ^define option_selected "<proc[Determine Selection Index].context[<def[num_options]>|<def[display_location]>]>"
    
    - ^define script <def[scripts].reverse.get[<def[option_selected]>]>
    - ^define arguments <def[argument_list].reverse.get[<def[option_selected]>].unescaped>
    - run <def[script]> def:<def[arguments]> instantly
    #- ^announce "<green>Running <gold><def[script]> <reset>with: <blue><def[arguments]>"


Context Menu Display Timeout:
    #
    # Removes entities after the timeout
    # Destroys the players display queue
    #
    type: task
    definitions: displays
    script:
    - remove <def[displays].unescaped>
    - queue queue:q@<player.name>_context_menu stop
