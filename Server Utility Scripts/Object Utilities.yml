#A set of scripts designed to replicate global namespace objects
#
#instead of define a new command called object?
#- object noob.intelligence ????
#
#- define noob.intelligence "5"
#- define noob.coding_skills "0"
#- narrate "noob with <def[noob].intelligence> brains and <def[coding_skills]> coding skills is realllllyyy a noob"
#- foreach <li@Each|time|he|studies> {
#    - define noob.intelligence ++
#    - define noob.coding_skills ++
#    }

#    - # define a new object
#    - Object  new_object
#    - #set its first attribute
#    - Object  new_object.name noobzilla
#    - Narrate "hi there <obj[new_object].name>"
#    - #attribute checking
#    - Object  new_object.job farmer
#    - If <obj[new_object].type.is[].to[]> == farmer {
#      - Narrate 'I see your job is <obj[new_object].job>, what is that?'
#      }
#    - Run "promote and announce" def:<obj[new_object]>

test_proc:
    type: task
    definitions: one|two
    script:
    - define test "li@one/1|
                    two/2|
                    three/3"
    - narrate "<def[test].map_get[one]>"

Object Database Startup:
    type: world
    path: script_database/object_database.yml
    events:
        on server start:
        - run "yaml load" def:<script.yaml_keys[path]>|object_database
        
        on server shutdown:
        - announce "<script.name> performing shutdown routine."


Object:
    #
    # - define kills <li@kills|10.escaped>
    # - define wins <li@wins|0.escaped>
    # - define none_or_setter <proc[object].context[red_team|set|<def[kills]>|<def[wins]>]>
    # - define team_stats <proc[object].context[red_team|get|kills|wins]>
    # - define team_red_wins <def[team_stats].get[]>
    # - define red_wins <proc[object].context[red_team|wins]>
    #
    type: procedure
    definitions: object_id|method
    script:
    - define object_id <def[object_id]||none>
    - if <def[object_id]> == null
      || <def[object_id]> == ''
      || <def[object_id]> == none {
        - event "script generates error" "context:message|invalid object id<&co> <def[object_id]>|script|<script>|queue|<queue>"
        - queue clear
        }
    - if !<yaml[object_database].contains[<def[object_id]>]> {
        - event "script generates error" "context:message|invalid object id<&co> <def[object_id]>|script|<script>|queue|<queue>"
        - queue clear
        }
    - if !<def[method].exists> {
        - event "script generates error" "context:message|Need an method refrence|script|<script>|queue|<queue>"
        - queue clear
        }
    - inject <def[method]> locally

    get:
    - define attribute_list li@
    - foreach <queue.definitions> {
        - if <def[value]> == object_id || <def[value]> == method foreach next
        - if !<yaml[object_database].contains[<def[object_id]>.<def[value]>]> {
            - define attribute_list <def[attribute_list].include[value_<def[value]>_not_found]>
            - foreach next
            }
        # include the attribute and add it to the attribute_list as escaped data (it could be a list)
        - define attribute_list <def[attribute].include[<yaml[object_database].read[<def[object_id]>.<def[value]>].escaped>]>
        }
    - determine <def[attribute_list]>
    
    set:
    - foreach <queue.definitions> {
        - if <def[value]> == object_id || <def[value]> == method foreach next
        - define data <def[%value%].unescaped.as_list>
        - define attrib <def[data].get[1]||none>
        - define value <def[data].get[2]||none>
        - if <def[attrib]> == none || <def[value]> == none foreach_next
        - yaml id:object_database set <def[object_id]>.<def[attrib]>:<def[value]>
        }
    - determine none









