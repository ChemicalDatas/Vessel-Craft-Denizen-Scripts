#A set of scripts designed to replicate global namespace objects
#
#instead of define a new command called object?
#- object noob.intelligence ????
#


Object Database Startup:
    type: world
    path: script_database/object_database.yml
    events:
        on server start:
        - run "yaml load" def:<script.yaml_key[path]>|temp_objects
        
        # on server shutdown.
        on stop command:
        - determine passively fulfilled
        - announce "<script.name> performing shutdown routine."

#note: to avoid a obscure bugs, objects might need to have the queue id prefixed to the object_id
Object:
    #Has the ability to handle multiple dynamic inputs
    #This has a scope that extends beyond script, as its more of a global variable
    #Get returns a list wether its 1 or multiple requests
    #
    #  #set an attribute on red_team
    # - define kills <li@kills|10.escaped>
    # - define wins <li@wins|0.escaped>
    # - define none_or_setter <proc[object].context[red_team|set|<def[kills]>|<def[wins]>]>
    #
    #  #get kills and wins
    # - define team_stats <proc[object].context[red_team|get|kills|wins]>
    # - define team_red_wins <def[team_stats].get[1]>
    #
    #  #just get the wins from redteam
    # - define red_wins <proc[object].context[red_team|get|wins]>
    #
    #  #clears the object from memory
    # - define clear_red_ream <proc[object].context[red_team|clear]>
    #
    # #raises an error and returns li@
    # - define red_wins <proc[object].context[red_team|get|wins]>
    type: procedure
    definitions: yaml_id|object_id|method
    script:
    #- inject "Announce Arguments Passed"
    # todo: reformat the ignored values to include .starts_with[__]
    # todo: add a method called delete to remove the yaml object from memory right away instead of waiting for the server to restart.
    # todo: change the adding or getting attributes with a map_get if possible. A key: value option style
    # todo: replace the checks with - inject typecheck
    - define yaml_id <def[yaml_id]||temp_objects>
    - if !<yaml.list.contains[<def[yaml_id]>]> {
        - debug error "invalid yaml id<&co> <def[yaml_id]>"
        - queue clear
        }
    - if <def[object_id]||none> == none {
        - debug error "invalid object id<&co> <def[object_id]>"
        - queue clear
        }
    - if <def[method]||none> == none {
        - debug "Need an method refrence"
        - queue clear
        }
    - inject <def[method]> locally
    
    get:
    - if !<yaml[<def[yaml_id]>].contains[<def[object_id]>]> {
        - debug "Object<&co> <red><def[object_id]><reset> does not exist."
        - queue clear
        }
    - define ignored_values li@
    - define ignored_values <def[ignored_values].include[<script.yaml_key[definitions].as_list>]>
    - define ignored_values <def[ignored_values].include[li@attribute_list|loop_index|ignored_values|value]>
    - define attribute_list li@
    - foreach <queue.definitions> {
        - if <def[ignored_values].contains[<def[value]>]> foreach next
        - if !<yaml[<def[yaml_id]>].contains[<def[object_id]>.<def[%value%]>]> {
            #I choose to raise the error instead of returning none
            #This mimicks a global variable and there isnt anyway to remove it unless the server restarts.
            #
            - debug error "Object<&co> <red><def[object_id]><reset> dose not have attribute<&co> <red><def[%value%]>"
            - foreach next
            }
        # include the attribute and add it to the attribute_list as escaped data (it could be a list)
        #- announce "trying to find <def[%value%]>"
        - define attribute_list <def[attribute_list].include[<yaml[object_database].read[<def[object_id]>.<def[%value%]>].escaped>]>
        }
    #- announce "object contains<&co> <yaml[object_database].list_deep_keys[<def[object_id]>]>"
    - determine <def[attribute_list]>
    
    set:
    - define ignored_values li@
    - define ignored_values <def[ignored_values].include[<script.yaml_key[definitions].as_list>]>
    - define ignored_values <def[ignored_values].include[li@|loop_index|ignored_values|value]>
    - foreach <queue.definitions> {
        - if <def[ignored_values].contains[<def[value]>]> foreach next
        - define data <def[%value%].unescaped.as_list>
        - define attrib <def[data].get[1]||none>
        - define value <def[data].get[2]||none>
        - if <def[attrib]> == none || <def[value]> == none foreach_next
        #- announce "setting <def[attrib]> <def[value]>"
        - yaml id:<def[yaml_id]> set <def[object_id]>.<def[attrib]>:<def[value]>
        }
    #- if <yaml[object_database].contains[<def[object_id]>]> {
    #    - narrate "<green>Sucessfully created object. <def[object_id]> is ready."
    #    } else {
    #    - narrate "<red>Failed to create object. <def[object_id]> is not in the yaml memory."
    #    }
    - determine none
    
    clear:
    - if !<yaml[<def[yaml_id]>].contains[<def[object_id]>]> {
        - debug error "Object<&co> <red><def[object_id]><reset> does not exist."
        - queue clear
        }
    - yaml id:<def[yaml_id]> set <def[object_id]>:!
    - determine none
    
    attributes:
    - if !<yaml[<def[yaml_id]>].contains[<def[object_id]>]> {
        - debug error "Object<&co> <red><def[object_id]><reset> does not exist."
        - queue clear
        }
    - determine <yaml[<def[yaml_id]>].list_deep_keys[<def[object_id]>]>
    







