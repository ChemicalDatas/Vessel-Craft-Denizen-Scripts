#A set of scripts designed to replicate global namespace objects
#
#instead of define a new command called object?
#- object noob.intelligence ????
#
#- define noob.intelligence "5"
#- define noob.coding_skills "0"
#- narrate "noob with <def[noob].intelligence> brains and <def[coding_skills]> coding skills is realllllyyy a noob"
#- foreach <li@Each|time|he|studies> {
#    - define noob.intelligence ++
#    - define noob.coding_skills ++
#    }

#    - # define a new object
#    - Object  new_object
#    - #set its first attribute
#    - Object  new_object.name noobzilla
#    - Narrate "hi there <obj[new_object].name>"
#    - #attribute checking
#    - Object  new_object.job farmer
#    - If <obj[new_object].type.is[].to[]> == farmer {
#      - Narrate 'I see your job is <obj[new_object].job>, what is that?'
#      }
#    - Run "promote and announce" def:<obj[new_object]>

test_proc:
    type: task
    definitions: one|two
    script:
    - define test "li@one/1|
                    two/2|
                    three/3"
    - narrate "<def[test].map_get[one]>"

Object Database Startup:
    type: world
    path: script_database/object_database.yml
    events:
        on server start:
        - run "yaml load" def:<script.yaml_keys[path]>|object_database
        
        on server shutdown:
        - announce "<script.name> performing shutdown routine."


Object:
    #Has the ability to handle multiple dynamic inputs
    #This has a scope that extends beyond script, as its more of a global variable
    #Get returns a list wether its 1 or multiple requests
    #
    #  #set an attribute on red_team
    # - define kills <li@kills|10.escaped>
    # - define wins <li@wins|0.escaped>
    # - define none_or_setter <proc[object].context[red_team|set|<def[kills]>|<def[wins]>]>
    #
    #  #get kills and wins
    # - define team_stats <proc[object].context[red_team|get|kills|wins]>
    # - define team_red_wins <def[team_stats].get[1]>
    #
    #  #just get the wins from redteam
    # - define red_wins <proc[object].context[red_team|get|wins]>
    #
    #  #clears the object from memory
    # - define clear_red_ream <proc[object].context[red_team|clear]>
    #
    # #raises an error and returns li@
    # - define red_wins <proc[object].context[red_team|get|wins]>
    type: procedure
    definitions: object_id|method
    script:
    #- inject "Announce Arguments Passed"
    - if <def[object_id]||none> == none {
        - event "script generates error" "context:message|invalid object id<&co> <def[object_id]>|script|<script>|queue|<queue>"
        - queue clear
        }
    - if <def[method]||none> == none {
        - event "script generates error" "context:message|Need an method refrence|script|<script>|queue|<queue>"
        - queue clear
        }
    - inject <def[method]> locally

    get:
    - if !<yaml[object_database].contains[<def[object_id]>]> {
        - event "script generates error" "context:message|Object<&co> <red><def[object_id]><reset> does not exist.|script|<script>|queue|<queue>"
        - queue clear
        }
    - define ignored_values li@
    - define ignored_values <def[ignored_values].include[<script.yaml_keys[definitions].as_list>]>
    - define ignored_values <def[ignored_values].include[li@attribute_list|loop_index|ignored_values|value]>
    - define attribute_list li@
    - foreach <queue.definitions> {
        - if <def[ignored_values].contains[<def[value]>]> foreach next
        - if !<yaml[object_database].contains[<def[object_id]>.<def[%value%]>]> {
            #I choose to raise the error instead of returning none
            #This mimicks a global variable and there isnt anyway to remove it unless the server restarts.
            #
            - event "script generates error" "context:message|Object<&co> <red><def[object_id]><reset> dose not have attribute<&co> <red><def[%value%]>|script|<script>|queue|<queue>"
            - foreach next
            }
        # include the attribute and add it to the attribute_list as escaped data (it could be a list)
        #- announce "trying to find <def[%value%]>"
        - define attribute_list <def[attribute_list].include[<yaml[object_database].read[<def[object_id]>.<def[%value%]>].escaped>]>
        }
    #- announce "object contains<&co> <yaml[object_database].list_deep_keys[<def[object_id]>]>"
    - determine <def[attribute_list]>
    
    set:
    - define ignored_values li@
    - define ignored_values <def[ignored_values].include[<script.yaml_keys[definitions].as_list>]>
    - define ignored_values <def[ignored_values].include[li@|loop_index|ignored_values|value]>
    - foreach <queue.definitions> {
        - if <def[ignored_values].contains[<def[value]>]> foreach next
        - define data <def[%value%].unescaped.as_list>
        - define attrib <def[data].get[1]||none>
        - define value <def[data].get[2]||none>
        - if <def[attrib]> == none || <def[value]> == none foreach_next
        #- announce "setting <def[attrib]> <def[value]>"
        - yaml id:object_database set <def[object_id]>.<def[attrib]>:<def[value]>
        }
    #- if <yaml[object_database].contains[<def[object_id]>]> {
    #    - narrate "<green>Sucessfully created object. <def[object_id]> is ready."
    #    } else {
    #    - narrate "<red>Failed to create object. <def[object_id]> is not in the yaml memory."
    #    }
    - determine none
    
    clear:
    - if !<yaml[object_database].contains[<def[object_id]>]> {
        - event "script generates error" "context:message|Object<&co> <red><def[object_id]><reset> does not exist.|script|<script>|queue|<queue>"
        - queue clear
        }
    - yaml id:object_database set <def[object_id]>:!
    - determine none







