#A set of test chat utilities for having chat click-able links that interact with npcs

Red or Blue_:
    type: world
    events:
        on choice_selector_ command:
        - foreach <context.args> {
            - announce "Argument <def[loop_index]>: <def[value]>"
            }
        - determine fulfilled


Test Chat Links_:
    #
    # This is an example of using denizen to construct a chat link that executes a 
    # command that denizen then reads the arguments for...
    # Im thinking useful for...
    #   spells
    #   chat inputs
    #   world teleportations
    #   command lists
    #
    # custom built commands?
    # smite player selection
    #   arguments command target
    #   - foreach <server.list_online_players>
    type: task
    script:
    - execute as_server "tellraw <player.name> {text:'hi there',color:'blue'}"
    - execute as_server "tellraw <player.name> {text:'Here your Text',color:'Here your color',extra:[{text:'Here your Second Text',color:'Here your Second Color',hoverEvent:{action:'show_text',value:'Here your Hover Text'},clickEvent:{action:'run_command',value:'/choice_selector_ red_pill swallow_it_quickly'}}]}"




##################################################################################################################
# The main needs of a json format script, Each node here provides the options needed for minecrafts 
# tellraw, title, signs, books clickable links feature for 1.8.x
##################################################################################################################

json example format:
    #This type is optional as denizen tries to load every .yml file into memory
    #I think if 
    type: task
    definitions: json_text1|players_choice|players_quest
    script:
    #Json minecraft datatypes
    #value: "text"
    #list:
    #- item1
    #- item2
    #- item3
    #compound:
    #   sub-element: "sub-value"
    #   sub-compound:
    #       sub-sub-compound: value
    #
    #Default Minecraft Json Tags
    text:
    - text
    selector:
    - selector
    insertion:
    - text
    translate:
    - language
    color:
    - color
    bold:
    - bool
    italic:
    - bool
    underlined:
    - bool
    strikethrough:
    - bool
    obfuscated:
    - bool
    
    # according the the minecraft forum post listed above it appears that click event / with / extra mappings, 
    # they can recieve a [list] of objects...
    # im not sure how to have that handled other than give the option to return a list in the format of [<proj:%whatever_you_return%>]
    clickEvent:
        action:
        - [action]
        value:
        - [value/url]
    hoverEvent:
        action: action
        value: [value/json/nbt]
    score:
        name: p@player.name
        objective: [server_objective]
    
    #with and extra are lists... even list of lists
    #sub list notation in yaml.... not a familiar thing in denizen....
    #The empty list notation is needed for this otherwise yaml thinks that its an error and not a list of lists
    #too bad you guys didnt use this way to note a list of lists in denizen instead of using '|'
    #This will most likely conflict with the - determine command. Thats why the proposed tag is suggested for purposes <json:json_script>
    #I might be able to produce our own <proc:json_script> tag that uses existing procedures to construct a set of json compatible data.
    with:
    -
        - [more json info]
        - [2 more json info]
        - [3 more json info]
    extra:
    -
        -
        -

#########################################################
#Personal Examples
#########################################################
Player Choice Command:
    type: world
    events:
        on nubz command:
        - announce "You selected your command! <red><context.args>"
        - determine fulfilled
        - run "Start Quest Branch" def:<context.args.get[first]>
    


JSON Test display:
    type: task
    script:
    -
    text: SubChoiceCommand
    color: gold
    hoverEvent:
        action: show_text
        value: hover events ftw!
    clickEvent:
        action: run_command
        value: /nubz testing
    


JSubChoiceSelector:
    type: task
    definitions: choice
    text:
    - determine <def[choice]>
    color:
    - determine gold
    clickEvent:
        action:
        - determine run_command
        value:
        - determine "current_player_quest_selection <def[choice]>"
    

JSONChoiceSelector:
    type: task
    definitions: json_text1|Choice_list|players_quest
    text:
    - determine <def[json_text1]||default_text>
    translate:
    - determine Pirate
    color:
    - determine red
    hoverEvent:
        action: 
        - determine show_text
        value: 
        - define text "<red>~[bheart]~ <gold>Please select your answer. <red>~[bheart]~"
        - determine <proc[iconize].context[<def[text]>]>
    extra:
    - define choice_list li@
    - foreach <def[choice_list].as_list> {
        - define extra_json "<json:JSON Npc Subchoice Selector.context[<def[value]>]>"
        - define choice_list <def[choice_list].extend[<def[extra_json]>]>
        }
    - determine <def[choice_list]>
    

    
ScriptParser:
    #
    # Takes a script and turns it into a json object from a yaml object....
    type: procedure
    definitions: script
    script:
    #
    #Parse yaml entries
    #Add parsed script entries into a fresh yaml
    #Turn that yaml into json
    - define yaml_id <util.random.duuid>
    - yaml load <def[script].relative_filename> id:<def[yaml_id]>
    #- define keys <yaml[temp].list_deep_keys>
    #Needs a recursive search
        #if a branch is a list, parse it using <proc[__return__].context[script|path]>
    
    - define current_path <def[script].name>
    - inject "Recursive Yaml Rewriter"
    - foreach <yaml[<def[yaml_id]>].list_keys> {
        - if <yaml[<def[yaml_id]>].is_list[<def[current_path]>]>
        - define value <yaml[<def[yaml_id]>].read[<def[path]>]>
        - yaml id:<def[yaml_id]> set <def[path]>:<def[parsed_value]>
        }
    
    #exclude type: definitions, script, and other script related entries
    - determine <yaml[<yaml_id>].to_json>
    
    

JsonFixer:
    type: procedure
    definitions: json
    script:
    - define replace_list "li@<&dq>text<&dq>|<&dq>selector<&dq>|<&dq>insertion<&dq>|<&dq>translate<&dq>|
      <&dq>color<&dq>|<&dq>bold<&dq>|<&dq>italic<&dq>|<&dq>strikethrough<&dq>|<&dq>obfuscated<&dq>|
      <&dq>clickEvent<&dq>|<&dq>action<&dq>|<&dq>hoverEvent<&dq>|<&dq>score<&dq>|<&dq>name<&dq>|
      <&dq>objective<&dq>|<&dq>with<&dq>|<&dq>extra<&dq>|<&dq>value<&dq>"
    - foreach <def[replace_list]> {
        - define json <def[json].replace[<def[value]>].with[<def[value].replace[<&dq>]>]>
        }
    - determine <def[json]>

testjson:
    type: task
    script:
    - define json "<proc[JsonFixer].context[<s@JSON Npc Subchoice Selector.to_json>]>"
    - execute as_op "broadcast <def[json]>"
    - execute as_op "tellraw <player.name> <def[json]>"
    
script title:
    #
    # This is an example of using denizen to construct a chat link that executes a 
    # command that denizen then reads the arguments for...
    # Im thinking useful for...
    #   spells
    #   chat inputs
    #   world teleportations
    #   command lists
    #
    # custom built commands?
    # smite player selection
    #   arguments command target
    #   - foreach <server.list_online_players>
    type: task
    definitions: script
    script:
    - define choice_text_1 "Your response to <npc.name>'s offer..."
    - define choice_list "li@Take the surrender|Fight to the end|Endure economic sanctions|Spend 20 years in prison"
    - define json "<proc[JsonFixer].context[<def[script].as_script.to_json>]>"
    - execute as_op "broadcast <def[json]>"
    - announce ""
    - execute as_op "title <player.name> title <def[json]>"






























