# A set of vesselcraft commands

Commands:
    ############################################################################################################################
    # A set of server commands usable on a server. Some might be useful some might not be.                                     #
    #                                                                                                                          #
    #                                                                                                                          #
    ############################################################################################################################
    type: world
    debug: false
        
    
    ########################################################################################################################
    #                                                                                                                      #
    # Each "arg" is the replaceable text for each argument sent with the shortcuts command.                                #
    #                                                                                                                      #
    ########################################################################################################################
    search: "he search p:arg t:arg"
    say: "say arg"
    express: "express arg"
    colors: "colors"
    allowed_groups:
    - Owner
    - Admin
    - MasterBuilder
    - Moderator
    - Builder
    
    title: "[<blue>Vessel<gold>Craft<reset>]"
    teleport_history_max: 10
    
    ########################################################################################################################
    #                                                                                                                      #
    # Default Messages                                                                                                     #
    #                                                                                                                      #
    ########################################################################################################################
    message:
        _permission denied: "<gold>[smile]<blue><player.name.display> <red>You are not allowed to use this command."
        facebook page: "https://www.facebook.com/VesselCraft"
        server page: ""
        
        voting page: "http://minecraft-mp.com/server-s32672"
        teamspeak ip: "vesselcraft.minecraftnoob.com"
        teamspeak password: "noob"
        teamspeak download: "http://www.teamspeak.com/?page=downloads"
        
        chat notify true:  "Chat Notifications <red>ON<dark_gray>. Chatting <player.name> will play a sound for you."
        chat notify false: "Chat Notifications <red>OFF<dark_gray>. Chatting <player.name> will <red>not<dark_gray> play a sound for you."
    
        place notify true:  "Place Notifications <red>ON<dark_gray>. Placing Debug is true."
        place notify false: "Place Notifications <red>OFF<dark_gray>. Placing Debug is false."
    
    
    ########################################################################################################################
    #                                                                                                                      #
    # is permitted is the basic set for perms checking.                                                                    #
    #                                                                                                                      #
    ########################################################################################################################
    is permitted:
    - if !<context.server> {
        - define groups <script.yaml_keys[allowed_groups]>
        - if "!<proc[In Allowed Group].context[<def[groups].escaped>]>" {
            - narrate format:Formatted "<script.yaml_key[message._permission denied]>"
            - queue clear
            }
        }
    
    events:
        on player join:
        - if <player.has_flag[can_fly]> flag <player> can_fly:!
        
        on player teleports:
        #this is checking perhaps for player type entities.... was  recent change in the underlying code....
        - if !<context.entity.is_player> queue clear
        - if <player.has_flag[backtracking_teleport_history]> {
            - flag player backtracking_teleport_history:!
            - queue clear
            }
        - if <context.destination.distance[<context.origin>].is[or_less].than[10]>
          queue clear
        
        - flag player teleport_history:|:<context.origin>
        
        - if <player.flag[teleport_history].as_list.size.is[or_more].than[<script.yaml_keys[teleport_history_max]>]> {
            - define new_history <player.flag[teleport_history].as_list.get[1].to[<script.yaml_keys[teleport_history_max]>]>
            - flag player teleport_history:!
            - flag player teleport_history:|:<def[new_history]>
            }
        
        on player death:
        - flag player teleport_history:|:<context.entity.location>
        
        on vc command:
        ########################################################################################################################
        #                                                                                                                      #
        # A command shortener based upon the data in the scripts constants: shortcut                                           #
        # Option to change later is the ammount of arguments passed with the command.                                          #
        # Just change the first args.get[your number] to whatever you want.                                                    #
        #                                                                                                                      #
        ########################################################################################################################
        - determine passively fulfilled
        - inject locally "is permitted"
        
        - define shortcut <context.args.get[1]>
        - define args <context.args.get[2].to[<context.args.size>]>
        - define input <script.yaml_keys[%shortcut%]>
        - define input "<def[input].split[ ]>"
        - define arg_index 1
        - define new_input ""
        
        ########################################################################################################################
        #                                                                                                                      #
        # Rebuilding the command sent                                                                                          #
        # If word = arg replace arg with the next value in the args sent with the command                                      #
        # increment arg_index so to get next index                                                                             #
        #                                                                                                                      #
        ########################################################################################################################
        - foreach <def[input]> {
            - define next_arg <def[args].get[<def[arg_index]>]>
            - if <def[value].contains[arg]> {
                - define new_input "<def[new_input]> <def[value].replace[arg].with[<def[next_arg]>]>"
                - define arg_index <def[arg_index].add[1]>
                } else {
                - define new_input "<def[new_input]> <def[new_value]>"
                }
            }
        
        #Just a filter from the null of a short command that's not there
        - if <def[new_input]> != null || <def[new_input]> != "" execute as_op <def[new_input]>
        
        
        on server_debug command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - if <server.has_flag[debug_output]> {
            - narrate "[Server Debug] Toggled Console Output: <red>off" 
            - flag server debug_output:!
            } else {
            - narrate "[Server Debug] Toggled Console Output: <red>on"
            - flag server debug_output:true
            }
        
        
        on debug command:
        - determine passively fulfilled
        - flag server
        - define toggle_true "Debug On"
        - define toggle_false "Debug Off"
        - run "Toggle Flag" "def:desires_debug|%toggle_true%|%toggle_false%|Toggled"
        
        
        
        on dnick command:
        - determine passively fulfilled
        - inject locally "is permitted"
        
        - if <context.args.size.is[more].than[1]> {
            - define player <context.args.get[1]>
            - define player <server.match_player[<def[player]>]||none>
            - if <def[player]> == none {
                - narrate "could not find a matching player for <context.args.get[1]>"
                - queue clear
                }
            - define name <context.args.get[2].as_string>
            } else {
            - define player <player>
            - define name <context.args.as_string>
            }
        
        - define name <proc[Iconize].context[<def[name]>]>
        - run "Rename Player" def:<def[name]> as:<def[player]>
        - narrate "<gray>Trying to change <reset><def[player].name>'s <gray>name to: <reset><def[name]><reset>."
        
        
        
        on colors command:
        - determine passively fulfilled
        - inject "Color Codes Announcment"
        

        on bossbar command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - define args <context.args.escaped>
        - define words <proc[Iconize].context[<def[args].escaped>]>
        - define debug_output "<red>Announcing to server online players: <green><def[words]>"
        - narrate format:Formatted <def[debug_output]>
        
        - run "Boss Bar" def:<def[words]>
        
        
        
        on teamspeak command:
        - determine passively fulfilled
        - narrate format:Formatted "<green><script.yaml_key[message.teamspeak ip]>"
        - narrate format:Formatted "<password>: <green><script.yaml_key[message.teamspeak password]>"
        
        
        
        on vote command:
        - determine passively fulfilled
        - narrate format:Formatted "<green><script.yaml_key[message.voting page]>"
        
        
        
        on webpage command:
        - determine passively fulfilled
        - narrate format:Formatted "<green><script.yaml_key[message.server page]>"
        - narrate format:Formatted "<green><script.yaml_key[message.facebook page]>"
        
        
        
        
        #as well as general clean up
        on timesync command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - if <server.has_flag[pause_time_sync]> {
            - ^narrate "The world time is <green>now <reset>syncing with server time."
            - ^flag server "pause_time_sync:!"
            } else {
            - ^narrate "The world time is <red>not <reset>syncing with server time." 
            - ^flag server "pause_time_sync:true"
            }
        
        
        
        on clearchat command:
        - determine passively fulfilled
        - run "Player Chat Clearing" def:19

        
        

        
        on placenotify command:
        - determine passively fulfilled
        - define toggle_true "<script.yaml_key[message.place notify true]>"
        - define toggle_false "<script.yaml_key[message.place notify false]>"
        - run "Toggle Flag" "def:place_notifications|%toggle_true%|%toggle_false%|Toggled"
        
        
        
        on chatnotify command:
        - determine passively fulfilled
        - define toggle_true "<script.yaml_key[message.chat notify true]>"
        - define toggle_false "<script.yaml_key[message.chat notify false]>"
        - run "Toggle Flag" "def:chat_notifications|%toggle_true%|%toggle_false%|Toggled"
        
        
        
        on signedit command:
        # This command depends on the mod server sign handling
        # This only sets up the options for the server to handle the player break sign event.
        - determine passively fulfilled
        - inject locally "is permitted"
        
        - define line <context.parsed_args.get[1]>
        - define text <context.parsed_args.get[2]>
        - define is_int "Is int: <proc[Is Int].context[%line%]>"
        - if "!<proc[Is Int].context[%line%]>" || %line% == null {
            - narrate format:SAI "You did not specify a line to edit. That should be your 2nd argument."                           
            - narrate format:SAI "<bold>ex: <reset><&dot><&bs><blue>signedit <yellow>1 <gray><&dq>This is your first line<&dq>"
            - queue clear
            }
        - if %text% = null {
            - define text "<reset>"
            } else {
            - define text <proc[Iconize].context[%text%]>
            }
            
        - narrate format:Formatted "<gray>Ready to edit line<white>: <gold>%line% <gray>with: <reset>%text%"
        - narrate format:Formatted "<gray>Please <underline>punch <gray>the <gold>sign(s) <gray>you want to change in <gold>10 <gray>seconds."
        
        - flag player "editing_sign:%line%|%text%" duration:10
        
        
        
        #on display command:
        #- determine passively fulfilled
        #- inject locally "is permitted"
        
        #- define display "<context.args.get[1]>"
        #- define location <player.location.cursor_on[3]>
        
        #- narrate "Summoning Display for you now."
        #- narrate "Please step back, as its anchor is there."
        #- narrate "Just chat to the display. It will change the display based on what you chat."
        #- execute as_op "npc create 'server display'"
        #- execute as_op "npc playerlist"
        #- invisible <player.selected_npc> toggle:true
        #- execute as_op "npc assign --set 'Nameplate Attractor'"
        
        on display command:
        - determine passively fulfilled
        - if <context.server> narrate "<script.yaml_keys[title]> <blue>Must be used ingame. Sorry."
        - inject locally "is permitted"
        - if <context.args.is_empty> 
          || <context.args.get[2].is[==].to[null]> {
            - narrate "<script.yaml_keys[title]> <blue>Usage is<&co> <yellow>./display (shop.swords sign.creative ..ect) (text)"
            - queue clear
            }
        - define flag <context.args.get[1]>
        - define location <player.location>
        - define text <parse:<context.args.get[2]>>
        - run "Server Display" def:<def[flag]>|<def[location]>|<def[text].escaped>
        
        
        
##############################################################################################################################        
        on player changes gamemode:
        - narrate "<script.yaml_keys[title]> <yellow>Your game mode was changed to: <light_purple><context.gamemode>"
        
        on gms command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - adjust <player> gamemode:survival
        - narrate "<script.yaml_keys[title]> <yellow>Current gamemode<&co> <light_purple><player.gamemode>"
        
        on gma command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - adjust <player> gamemode:adventure
        - narrate "<script.yaml_keys[title]> <yellow>Current gamemode<&co> <light_purple><player.gamemode>"
        
        on gmc command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - adjust <player> gamemode:creative
        - narrate "<script.yaml_keys[title]> <yellow>Current gamemode<&co> <light_purple><player.gamemode>"
        
        on fly command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - if <player.has_flag[can_fly]> {
            - adjust <player> can_fly:false
            - flag player can_fly:!
            - narrate "<script.yaml_keys[title]> <yellow>Hope your on the <red>ground."
            } else {
            - adjust <player> can_fly:true
            - flag player can_fly
            - narrate "<script.yaml_keys[title]> <yellow>You can now <blue>fly!"
            }
        
        on smite command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - strike <player.location.cursor_on[100]>
        
        on time command:
        - determine passively fulfilled
        - if <context.args.is_empty> {
            - narrate "<script.yaml_keys[title]> <yellow>The time is <player.world.time> ticks"
            - queue clear
            }
        - inject locally "is permitted"
        - define dawn 23500
        - define morning 0
        - define noon 6000
        - define day 6000
        - define dusk 12000
        - define night 18000
        - define accessor <context.args.get[1]>
        - define time <def[%accessor%]||<context.args.get[1]>>
        - if <def[time].as_int> == null {
            - narrate "<script.yaml_keys[title]> <blue>The argument you passed wasnt recogniced time. Ex<&co> <yellow>dawn, morning, noon, day, dusk, night, 0-24000"
            - queue clear
            }
        - time <def[time]>t
        - announce "<script.yaml_keys[title]> <reset><player.name.display><reset> set the time to <yellow><def[time]>."
        
        on day command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - time 0t
        - narrate "<script.yaml_keys[title]> <yellow>Set the time to <player.world.time> ticks."
        
        on night command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - time 18000t
        - narrate "<script.yaml_keys[title]> <yellow>Set the time to <player.world.time> ticks."
        
        on sun command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - weather sunny
        - narrate "<script.yaml_keys[title]> <yellow>The weather was set to <red>SUN"
        on storm command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - weather storm
        - narrate "<script.yaml_keys[title]> <yellow>The weather was set to <red>STORM"
        on thunder command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - weather thunder
        - narrate "<script.yaml_keys[title]> <yellow>The weather was set to <red>THUNDER"
        
        on world command:
        - determine passively fulfilled
        - define world <context.args.get[1]||none>
        - if !<server.list_worlds.contains[<def[world].as_world>]> {
            - narrate "<script.yaml_keys[title]> <yellow>This server contains the worlds<&co> <blue><&nl><server.list_worlds.parse[name]>"
            - if <def[world].is[!=].to[none]>
              narrate "<green><def[world]><yellow> was not on that list."
            - queue clear
            }
        - teleport <def[world].as_world.spawn_location>
        - narrate "<script.yaml_keys[title]> <yellow>Ok, sending you to <def[world]>"
        
        on i command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - define item <context.args.get[1]>[quantity=<context.args.get[2]||<context.args.get[1].max_stack>>]
        - define item <def[item].as_item||Not_An_Item>
        - if <def[item].type||Not_An_Item> != "Item"  {
            - narrate "<script.yaml_keys[title]> <red>Not an item. <blue>It was<&co> <def[item].type||%item%>"
            - queue clear
            }
        - narrate "<script.yaml_keys[title]> <blue>Giving you <def[item].formatted>"
        - give <def[item]>


 
        on ci command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - define target <player||null>
        - if !<context.args.is_empty>
            define target <server.match_player[<context.args.get[1]>]>
        - if <def[target]> == null {
            - narrate "<script.yaml_keys[title]> <red>Could not find the specified target. <yellow><context.args.get[1]>"
            - narrate "<script.yaml_keys[title]> <blue>Usage<&co> ./ci [player]"
            - queue clear
            }
        - narrate "<script.yaml_keys[title]> <blue>Clearing <red><def[target].name.display||<def[target].name>><blue><&sq>s inventory"
        - narrate "<script.yaml_keys[title]> <blue>Your inventory was <yellow>cleared." targets:<def[target]>
        - inventory clear d:<def[target].inventory>


        on give command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - if <context.args.is_empty>
          || <context.args.get[1]||no_player_specified> == "no_player_specified"
          || <context.args.get[2].replace[minecraft<&co>].as_item.type.is[==].to[item]||unmatchable_item> == "unmatchable_item" {
            - narrate "<script.yaml_keys[title]> <blue>Your input<&co> <yellow>./give <context.args.get[1]||NO_Player> <context.args.get[2]||NO_ITEM> <context.args.get[3]||NO_AMMOUNT_SPECIFIED>"
            - narrate "<script.yaml_keys[title]> <blue>Usage<&co> ./give (player) (item) [ammount]"
            - queue clear
            }
        
        - define target <server.match_player[<context.args.get[1]>]>
        - if <def[target]> == null {
            - narrate "<script.yaml_keys[title]> <red>Could not find the specified target. <yellow><context.args.get[1]>"
            - narrate "<script.yaml_keys[title]> <blue>Usage<&co> ./give (player) (item) [ammount]"
            - queue clear
            }

        - define item <context.args.get[2].replace[minecraft<&co>].as_item||Not_An_Item>
        - narrate "<script.yaml_keys[title]> <blue>Giving <red><def[target].name.display||<def[target].name>> <green><def[item].formatted||<def[item].simple>><blue>. Qty<&co> <yellow><context.args.get[3]||1>"  targets:<player>
        - narrate "<script.yaml_keys[title]> <blue>Giving you <def[item].formatted||<def[item].simple>>. <yellow>Present from<&co> <green><player.name.display||<player.name||Console>>"            targets:<def[target]>
        - give <def[item]> to:<def[target].inventory> qty:<context.args.get[3]||1>
        
        on leap command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - define target <player||null>
        - define strength <context.args.get[2]||1>
        - if !<context.args.is_empty>
            define target <server.match_player[<context.args.get[1]||null>]>
        - if <def[target]> == null {
            - narrate "<script.yaml_keys[title]> <red>Could not find the specified target. <yellow><context.args.get[1]>"
            - narrate "<script.yaml_keys[title]> <blue>Usage<&co> ./leap (player)"
            - queue clear
            }
        - adjust <def[target]> velocity:<def[target].location.direction.vector.mul[<def[strength]>]>
        
        on ping command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - random 5
        - narrate "<red>Pong"
        - narrate "<blue>Pong"
        - narrate "<green>Pong"
        - narrate "<yellow>Pong"
        - narrate "<light_purple>Pong"
         
        on speed command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - define speed <context.args.get[1].div[5]||.2>
        - if <player.is_flying> {
           - adjust <player> fly_speed:<def[speed]>
           - narrate "<script.yaml_keys[title]> <blue>Set your flying speed to<&co> <yellow><def[speed].mul[5]>"
           } else {
           - adjust <player> walk_speed:<def[speed]>
           - narrate "<script.yaml_keys[title]> <blue>Set your walking speed to<&co> <yellow><def[speed].mul[5]>"
           }
        
        #provide a targeting option from console or others
        on mob command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - if <context.server> {
            - narrate "Sorry man, Youll need to be ingame to send any mobs the way you might be looking..."
            - queue clear
            }
        - if <context.args.is_empty> {
            - narrate "<script.yaml_keys[title]> <blue>Usage<&co> <light_purple>./mob cow|enderman|<&lt>server.match_player[<server.list_ops.random.name>]<&gt>"
            - queue clear
            }
        - mount <parse:<context.args>> <player.location.cursor_on.above>
        
        #provide a targeting option to automaticaly send a player
        on back command:
        - determine passively fulfilled
        - inject locally "is permitted"
        - if <context.server> == console {
            - narrate "Sorry man, Youll need to be ingame to be sent back where you were teleported from......"
            - queue clear
            }
        - if !<player.has_flag[teleport_history]> {
            - narrate "<script.yaml_keys[title]> <blue>Sorry, you have no teleport history."
            - queue clear
            }
        - define history_target <context.args.get[1]||0>
        - if <def[history_target].as_int> == null {
            - narrate "<script.yaml_keys[title]> <blue>Sorry, <yellow><def[history_target]> <bluw>was not a recogenisable number to use to get your history with."
            }
        - define size <player.flag[teleport_history].as_list.size>
        - define index <def[size].sub[<context.args.get[1]||0>]>
        - flag player backtracking_teleport_history
        - teleport <player> <player.flag[teleport_history].as_list.get[<def[index]>]>
        
        
        
        
#        on hurt command:
#        - determine passively fulfilled
#        - inject locally "is permitted"/lo
#        - if <context.args.is_empty>
#          || <context.args.get[1]||no_player_specified> == "no_player_specified"
#          || <context.args.get[2].as_item.type.is[==].to[item]||unmatchable_item> == "unmatchable_item" {
#            - narrate "<script.yaml_keys[title]> <blue>Your input<&co> <yellow>./give <context.args.get[1]||NO_Player> <context.args.get[2]||NO_ITEM> <context.args.get[3]||NO_AMMOUNT_SPECIFIED>"
#            - narrate "<script.yaml_keys[title]> <blue>Usage<&co> ./give (player) (item) [ammount]"
#            - queue clear
#            }
        
        #
        #on heal command:
        #   also heal statuses
        #   boost saturation
        #   boost food
        #on powertool command:
        #
        #on killall command:
        #list server entities excluding
        #   entites with owners
        #   players
        #   itemframes
        #   armor stands
        #
        #INcluding
        #   items
        #   mobs
        #   friendly mobs
        #   projectiles
        #- define targets <player.location.find.entities[].within[]>



