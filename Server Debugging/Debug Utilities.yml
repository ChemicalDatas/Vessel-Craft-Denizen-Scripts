#################################################################################################################################
#                                                                                                                               #
# A Set of debugging ideas that might be useful for others.                                                                     #
#                                                                                                                               #
#                                                                                                                               #
#################################################################################################################################


#todo: have the server flaged to output to a type of output.
#   log
#   console
#   to_ops
#   to_flagged
#   none
#todo: Create a yaml object representing the error for storage while the server runs
#todo the output feature will read a yaml object thats a culmulation of the error
#yaml object should contain
#   relative file name
#   The error message

#The error yaml file should be ordered by
#   error type: ex, invalid tag, exceptions, command errors.... 
#       script:
#           line of erroring code
#
#Possible to determine a failed ./ex command
# queue.id.split[_].contains[EXCOMMAND]
#
#        #loc/yaml_keys[<&lt>def[script]<&gt>].size|
#        #step/step[<&lt>player<&gt>]|
#        #assigned_to/get_npcs_assigned[<&lt>def[script]<&gt>]
#
#
#            - define script_max_lines_of_code   <def[skript].yaml_keys[script].size>
#            - define remaining_lines_of_code    <def[size]>
#            - define script_failed_line         <def[script_max_lines_of_code].sub[<def[remaining_lines_of_code]>]>
#            
#            - define offending_line             <def[skript].yaml_keys[script].get[<def[script_failed_line]>]>
#            - define command                   "<def[offending_line].split[ ].get[1]>"
#            - define arguments                  "<def[offending_line].split[ ].get[2].to[<def[offending_line].split[ ].size>]>"
#
# todo: have some default type checking built into scripts
#


Determine Error Type:
    type: procedure
    definitions: message
    script:
     - define error_types "li@Missing Tag|Invalid dCommand|Invalid Arguments|Depreciated|Internal exception was thrown!"
     -
     - determine <def[error_type]>


ScriptDebug:
    type: world
    script_error_object_file: script_error_objects.yml
    events:
        on server start:
        - run "yaml load" def:<script.yaml_keys[script_error_object_file]>|error_objects
        - while true {
            - wait d@1h
            - run "yaml save" def:<script.yaml_keys[script_error_object_file]>|error_objects
            }
        
        #on server stop
        on stop command:
        - determine passively fulfilled
        - run "yaml save" def:<script.yaml_keys[script_error_object_file]>|error_objects
        - narrate "Saving yaml for <script.name>"
        
        on script generates error:
        - if !<server.has_flag[debug_output]> queue clear
#        - if <context.script||none> != none {
#            - yaml
#              load:<context.script.relative_filename>
#              id:<context.script.name>
#              
#            - run "Build Yaml Error Object"
#              def:<context.message>|<context.queue>|<context.script>
#            }
        - define player "
          <context.queue.player||
          <queue.player||
          <player||
          none>>>"
        
        - define npc "
          <context.queue.npc||
          <queue.npc||
          <player.selected_npc||
          none>>>"
        
        - define queue
          <context.queue||none>
        
        - define script
          <context.script||none>
        
        - inject "get debug data"
        
        #ignored printing data based off of whats generated in the script get debug data
        - define ignored_data 
            li@none|ignored_data|loop_index|value|type|accessor|attribute|object|accessor_types|npc_accessors|player_accessors|queue_accessors|script_accessors
        
        - define ignored_data
          <def[ignored_data].include[player_list_flags]>
        
        - if <def[script].relative_filename||none> != none {
            - define file_location <def[script].relative_filename.split[<&dot>].get[1]>
            - define file_location /plugins/denizen<def[file_location]>
            - define file_name <def[script].name>_errors.log
            } else {
            - define file_location /plugins/denizen/scripts
            - define file_name general_errors.log
            }
        
        
        - define file <def[file_location]>_error_log/<def[file_name]>
        #- announce "file<&co> <def[file]>"
        #- define file /plugins/denizen/script_errors.log
        
        #output
        - announce "<red>[<def[script].name||NOSCRIPT>] <blue><context.message>"
        - log "=======<script.name>======="                                                                 type:warning file:<def[file]>
        - log "Script<&co> <&lb><def[script].name||Unknown Script><&rb> <--- Generated an error."           type:none file:<def[file]>
        - log "The message is as follows<&co>"                                                              type:none file:<def[file]>
        - log "<context.message>"                                                                           type:none file:<def[file]>
        - foreach <queue.definitions.alphanumeric> {
            - if <def[ignored_data].contains[<def[value]>]> 
              || <def[%value%]> == none {
                - foreach next
                }
            - log "<&lb><def[value]><&rb> <def[%value%]>"                                                   type:none file:<def[file]>
            }
        - log "=======Finished with Debug Data======="                                                      type:none file:<def[file]>
        
        
        on server generates exception:
        #- if !<server.has_flag[debug_output]> queue clear
        #- run "Notify Debug" def:<context.message>|<context.queue||none>|<context.script||none> instantly


Get Debug Data:
    #
    # INJECTED SCRIPT
    # This script defines data based on the definitions within
    #
    #this requires definitions to be already defined,
    # - define player <player>
    # - define player <queue.player>
    # - define queue <context.queue>
    # - define script <s@testing_sorta>
    # - define npc <player.selected_npc>
    type: task
    script:
    - define queue_accessors "
        id/id|
        size/size|
        state/state|
        script/script|
        determination/determination|
        type/type|
        speed/speed|
        commands/commands|
        debug/script.debug|
        definitions/definitions"
    
    - define script_accessors "
        container_type/container_type|
        cooled_down/cooled_down|
        filename/filename|
        relative_filename/relative_filename|
        name/name|
        debug/debug|
        prefix/prefix|
        object_type/object_type"
        #loc/yaml_keys[<&lt>def[script]<&gt>].size|
        #step/step[<&lt>player<&gt>]|
        #assigned_to/get_npcs_assigned[<&lt>def[script]<&gt>]
    
    - define npc_accessors "
        id/id|
        spawned/spawned|
        owner/owner|
        name/name|
        nickname/nickname|
        protected/is_protected|
        lookclose/lookclose|
        previous_location/.location.previous_location.simple|
        location/location.simple|
        nav_target/navigator.target_location|
        teleport_on_stuck/teleport_on_stuck|
        navigating/navigator.is_navigating|
        base_speed/navigator.base_speed|
        range/navigator.range|
        attack_range/navigator.attack_range|
        stratagey/navigator.attack_stratagey|
        speed_modifier/navigator.speed_modifier|
        speed/navigator.base_speed|
        avoid_water/navigator.avoid_water|
        base_speed/navigator|
        has_assignment/has_script|
        script/script|
        flags/list_flags|
        engaged/is_engaged|
        anchors/anchor.list|
        inventory/inventory.list_contents|
        traits/traits|
        nearby_npcs/location.find.npcs.within[25]"
    
    - define player_accessors "
        name/name|
        display_name/name.display|
        list_name/name.list|
        entity_id/eid|
        save_name/save_name|
        prefix/prefix|
        selected_npc/selected_npc|
        is_op/is_op|
        location/location.simple|
        chat_history/chat_history_list|
        target/target|
        open_inventory/open_inventory|
        is_op/is_op|
        location/location.simple|
        chat_history/chat_history_list|
        target/target|
        open_inventory/open_inventory|
        item_on_cursor/item_on_cursor|
        money/money|
        list_flags/list_flags.alphabetical|
        fall_distance/fall_distance|
        debug/debug"
    
    #this requires definitions to be already defined,
    # - define player <player||none>
    # - define player <queue.player||none>
    # - define queue <context.queue||none>
    # - define script <s@testing_sorta||none>
    # - define npc <player.selected_npc||none>
    
    #todo: maybe I might want to add to a list of attributes instead of creating definitions
    #by reason of possibility of overwriting other definitions within a script
    #thats why the definition created is %type%_%attribute%  or npc_location instead of just location
    - define accessor_types li@queue|script|player|npc
    - foreach <def[accessor_types]> {
        #store the type so its not overwritten later
        - define type %value%
        #get the calling scripts value
        - define object <def[%value%]||none>
        #if there was a failed or no definition at all
        - if <def[object]> == none foreach next
        #foreach local definitions, queue_accessors, etc...
        - foreach <def[%type%_accessors].as_list> {
            #split the name from the accessor value
            - define attribute <def[value].split[/].get[1]>
            - define accessor <def[value].split[/].get[2]>
            ##access the attributes on the calling scripts object. eg player.name, queue.size, etc...
            - define %type%_%attribute% <def[object].%accessor%||none>
            }
        }
    



debug format:
    type: format
    format: "<proc[Iconize].context[<dark_blue>[debugger]<reset> <text>]>"



"Debug Dispatcher":
    #############################################################################################################################
    #                                                                                                                           #
    # Debug dispatcher will unescape the information sent to the dispatcher.                                                    #
    #                                                                                                                           #
    # Id like this to have multiple ways to inform the player of the debug                                                      #
    # 1 boss bar                                                                                                                #
    # 2 side bar                                                                                                                #
    # 3 in a book                                                                                                               #
    # 4 Under the npc name?                                                                                                     #
    # 5 In the tab menu.                                                                                                        #
    # 6 Using the holo menus                                                                                                    #
    # 7 Plain old Chat Display                                                                                                  #
    # 8 Using the log command                                                                                                   #
    #                                                                                                                           #
    #############################################################################################################################
    type: task
    debug: true
    definitions: debug_text|method_of_display
    script:
    - define debug_text <def[debug_text].unescaped>
    - define method_of_display <def[method_of_display].unescaped||chat>
    
#
"x5":
    #
    # A script for testing out an idea for denizen automated script tests
    #
    scripttest:
        test_1:
            input: 1
            expected: 5
            setup:
            - define scripts_input "<script.yaml_key[scripttest.test_1.input]>"
            test:
            - define scripts_real_return <proc[<script.name>].context[<def[scripts_input]>]>
            teardown:
            - announce Tearing_down_script
            - flag server delete_me !
            
    type: procedure
    definitions: number
    script:
    - determine <def[number].mul[5]>


"Test Path":
    scripttest:
        test_1:
            input:
            expected: "This is the <blue>expected value"
            setup:
            test:
            teardown:
    type: procedure
    definitions:
    script:
    - determine "But this is the <red>received value"
    
"STest":
    #
    # A script that runs the tests set up in the script name provided
    #
    # The script in question requires 
    #
    type: task
    definitions: script_name
    script:
    - define path <def[script_name].relative_filename>
    - yaml load:<def[path]> id:UT
    - announce "<blue>Loaded yaml ids: <yellow><yaml.list>" to_console
    
    - define number_of_tests <yaml[UT].list_keys[<def[script_name]>.scripttest].size>
    - announce "<blue>Starting <green><def[number_of_tests]> <blue>tests." to_console
    - repeat <def[number_of_tests]> {
        - define path scripttest.test_<def[value]>
        - if <def[script_name].container_type> == procedure {
            - inject <def[script_name]> "path:<def[path]>.setup"
            - inject <def[script_name]> "path:<def[path]>.test"
            - inject <def[script_name]> "path:<def[path]>.teardown"
            - define scripts_expected_return <def[script_name].constant[<def[path]>.expected]>
            - if <def[scripts_real_return]> == <def[scripts_expected_return]> {
                - define script_name <def[script_name]>
                - define test_results "<proc[Append Right].context[]>"
                - define test_names
                - announce "<gold>Script was successful" to_console
                - announce "<blue>Scripts Return: <gold><def[scripts_real_return]>" to_console
                - announce "<blue>Expected Value: <gold><def[scripts_expected_return]>" to_console
                } else {
                - announce "<red>Script failed"
                }
            }
        
        - if <def[script_name].constant[type]> == task {
            - announce "Testing a task"
            - run <def[script_name]> path:script2
            }
        }
        
    
    - yaml unload id:UT


Announce Arguments Passed:
    #Injected script to announce all the args passed to a script
    #If placed at the end of a script, this will gather the names of all definitions within a script.
    type: task
    script:
    - announce ""
    - announce "<red><magic>ii<reset><bold>Arguments to <blue><bold><queue.script.name><reset><red><magic>ii<reset><red>:"
    - foreach <queue.definitions> {
        - announce "<blue><bold>%value%: <reset><def[%value%]>"
        }


__objt:
    type: task
    definitions: none
    script:
    - define type li@player|queue|script|npc
    - foreach <def[type]> {
        - define object <%value%>
        - narrate ''
        - narrate "%value% %object% <def[object]> <def[object].type>"
        }

__queuet:
    type: task
    script:
    - define queue <queue>
    - define queue_accessors "queue_id/id|
                            queue_size/size|
                            queue_ state/state|
                            queue_script/script|
                            queue_determination/determination|
                            queue_type/type|
                            queue_speed/speed|
                            queue_commands/commands|
                            queue_debug/script.debug|
                            queue_definitions/definitions"
    
    - foreach <def[queue_accessors].as_list> {
        - define attribute <def[value].split[/].get[1]>
        - define accessor <def[value].split[/].get[2]>
        - define %attribute% <def[queue].%accessor%||none>
        - narrate "<green>%attribute%<&co> <gold><def[%attribute%]>"
        
        
        }
    - narrate ""
    - narrate ""
    


#todo: check if using not only type checking but default_values too....
#Its possible to use <el@type.type>, .as_list returns list, and "strings" return elements.
#But '1'.type returns element instead of int. Only way to determine valid ints for math tags is "element.as_int"
#if that returns as valid then its truly something the scripts can use.
typecheck:
    #
    #injected script for checking type values predefined within a script.
    # if a script has 2 set values location and outset. There needs to be 
    # yaml keys prefixed with type_ and contains a acessor value. That needs to be returned as valid
    # for this to raise an input error
    #script:
    #   type_int: as_int
    #   type_element: prefix
    #   type_player: as_player
    #   type_queue: as_queue
    #   definitions: int|element|player|queue
    #   script:
    #   - narrate "yada yada"
    #
    #The types need to be of similar name as the definitions
    #
    # Todo: add support for special values and accessors ex: contains[__must_contain_this_value],
    # this might be beyond the scope and the security value of the script.
    #
    type: task
    speed: 0t
    script:
    - ^define __ignored_values
      li@value|loop_index|__ignored_values|__required_script_definitions|__present_definitions
    
    - ^define __required_script_definitions
      <queue.script.yaml_keys[definitions].as_list||none>
    
    - if <def[__required_script_definitions]> != none {
        
        - ^define __present_definitions
          <queue.definitions.exclude[<def[__ignored_values]>]>
        
        - if <def[__present_definitions].size.is[less].than[<def[__required_script_definitions].size>]> {
            - define __missing_definitions
              <def[__required_script_definitions].exclude[<def[__present_definitions]>]>
            
            - foreach <def[__missing_definitions]> {
                - if <queue.script.yaml_keys[default_<def[value]>]||none> != none
                  define __missing_definitions <def[__missing_definitions].exclude[<def[value]>]>
                }
            
            - if !<def[__missing_definitions].is_empty> {
                - ^define __message
                  "Definition(s) failed type check. Missing definitions<&co> <red><def[__missing_definitions].as_string>"
                
                - ^event "script generates error"
                  context:message|<def[__message]>|script|<queue.script>|queue|<queue>
                
                - queue clear
                }
            }
        
        - foreach <def[__present_definitions]> {
            #- announce "<script.name> checking for <def[value]>"
            
            - if <def[value].starts_with[__]>
              foreach next
            
            - ^define __accessor
              <queue.script.yaml_keys[type_%value%]||none>
            
            - if <def[__accessor]> == none 
              foreach next
            
            #- announce "<script.name> <def[%value%]>.%__accessor% <def[%value%].%__accessor%||failed_tag>"
            
            - ^define __expected_value
              <def[%value%].%__accessor%||failed_tag>
            
            - if <def[__expected_value]> == failed_tag {
                - ^define __message "Definition(s) failed type check. def<&co><def[value]> value<&co><def[%value%]> type_check<&co><def[__accessor]>"
                - ^event "script generates error" context:message|<def[__message]>|script|<queue.script>|queue|<queue>
                - queue clear
                }
            }
        }
    
__tstchecking:
    type: task
    type_int: as_int
    type_element: prefix
    definitions: int|element
    script:
    - inject typecheck
    - announce "<def[int]> <def[int].type>"
    - announce "<script.name> completed its task and did not raise an error."





__Notify Debug:
    type: task
    definitions: error_message|queue|skript
    script:
    - define time           "<util.date.time> <red><util.date.time.second> <gold>seconds"
    - if <def[queue]||none> != none {
        - define id             <def[queue].id>
        - define size           <def[queue].size>
        - define state          <def[queue].state>
        - define script         "<def[queue].script||No script associated with queue>"
        - define determination  "<def[queue].determination||No determination>"
        - define type           <def[queue].type>
        - define speed          <def[queue].speed>
        - define commands       <def[queue].commands||None>
        - define debug          "<def[queue].script.debug||Has no steps>"
        - define queue_debug "
            script<&co>                 <def[script]><&nl>
            id<&co>                        <def[id]><&nl>
            type<&co>                    <def[type]><&nl>
            state<&co>                  <def[state]><&nl>
            speed<&co>                <def[speed]><&nl>
            size<&co>                    <def[size]><&nl>
            debug<&co>                <def[debug]><&nl>
            Remaining Commands:<&nl>
            <def[commands]><&nl>
            <&nl>#<&nl>
            <&nl>#<&nl>
            "
        } else {
        - define queue_debug "There was no associated script.<&nl>"
        }
    
    
    - if <def[skript]||none> != none {
        - define no_container       "Has no script container"
        - define no_steps           "Has no steps"
        - define no_cooldown        "Has no cooldown"
        - define unknown_loc        "Unknown File Location"
        - define container          <def[skript].container_type||<def[no_container]>>
        - define cooled_down        <def[skript].cooled_down[<player||none>]||<def[no_cooldown]>>
        - define script_file        <def[skript].filename||<def[unknown_loc]>>
        - define script_relfile     <def[skript].relative_filename||<def[unknown_loc]>>
        - define script_name        <def[skript].name||<def[no_container]>>
        - define script_LOC_total   <def[skript].yaml_keys[script].size>
        - define step               <def[skript].step[<player||>]||<def[no_container]>>
        - define debug              <def[skript].debug||<def[no_steps]>>
        - define prefix             <def[skript].prefix||<def[no_container]>>
        - define object_type        <def[skript].object_type||<def[no_container]>>
        - define assigned_npcs      <server.get_npcs_assigned[<def[skript]>]||None>
        - define script_defins      <def[queue].definitions||li@>
        - define fallback_value     "(unable to get value)"
        - foreach <def[script_defins]> {
            - define text "<def[value]>: <def[%value%]||<def[fallback_value]>>"
            - define definition_values "<&nl><proc[Append Right].context[<def[definition_values]||>|<def[text]>]>"
            }
        
        # Determination of the offending script line
        - define "request Could use a tag for a queue indicating the event or action that fired the queue... queue.event or queue.action maybe?"
        - define scripts li@task|procedure
        - define events li@world
        - define actions li@assignment
        - if <def[scripts].contains[<def[script].yaml_keys[type]>]> {
            - define script_max_lines_of_code   <def[skript].yaml_keys[script].size>
            - define remaining_lines_of_code    <def[size]>
            - define script_failed_line         <def[script_max_lines_of_code].sub[<def[remaining_lines_of_code]>]>
            
            - define offending_line             <def[skript].yaml_keys[script].get[<def[script_failed_line]>]>
            - define command                   "<def[offending_line].split[ ].get[1]>"
            - define arguments                  "<def[offending_line].split[ ].get[2].to[<def[offending_line].split[ ].size>]>"
            
            - define line_error "
            script total lines<&co>   <def[script_LOC_total]><&nl>
            script line <&ns><&co>           <def[script_failed_line]><&nl>
            offending code<&co>     <def[offending_line]><&nl>
            error<&co>                       <def[error_message]><&nl>
            <&nl>#<&nl>
            command<&co>             <def[command]><&nl>
            its arguments<&co>      <def[arguments]><&nl>
            command_help<&co>          <&nl>http://mcmonkey.org/denizen/cmds/<def[command]><&nl>
            "
            } else {
            - define line_error "
            Please use this to debug your script<&co><&nl>
            Remaining Commands<&co><&nl>
            <def[commands]><&nl>
            "
            }
        
        
        - define script_debug "
        script_location<&co>      <def[script_file]><&nl>
        relative location<&co>     <def[script_relfile]><&nl>
        script_name<&co>          <def[script_name]><&nl>
        definitions<&co>             <def[script_defins]><&nl>
        definition_values<&co> <def[definition_values]><&nl>
        object_type<&co>           <def[object_type]><&nl>
        prefix<&co>                      <def[prefix]><&nl>
        container<&co>               <def[container]><&nl>
        step<&co>                        <def[step]><&nl>
        cooled_down<&co>       <def[cooled_down]><&nl>
        assigned_npcs<&co>   <def[assigned_npcs]><&nl>
        determination<&co>      <def[determination]><&nl>
        <&nl>#<&nl>
        <def[line_error]>
        <&nl>#<&nl>
        <&nl>#<&nl>
        "
        } else {
        - define script_debug "There was no associated script.<&nl>"
        }
    
    - if <def[queue].npc||none> != none {
        - define n                      <def[queue].npc>
        - define npc_id                 <def[n].id||No_Id>
        - define npc_spawned            <def[n].spawned||Not_Spawned>
        - define npc_owner              <def[n].owner||No_Owner>
        - define npc_name               <def[n].name||No_name>
        - define npc_nickname           <def[n].nickname||No_Nickname>
        - define npc_isprotected        <def[n].is_protected||Not_Protected>
        - define npc_lookclose          <def[n].lookclose||Lookclose_Not_Applicable>
        
        - define npc_prev_location      <def[n].location.previous_location.simple||No_Previous_Location>
        - define npc_location           <def[n].location.simple||No_location>
        - define npc_nav_target_loc     <def[n].navigator.target_location||No_Target_Location>
        - define npc_tp_onstuck         <def[n].teleport_on_stuck||No_Teleport_On_Stuck>
        - define npc_is_navigating      <def[n].navigator.is_navigating||Not_Applicable>
        - define npc_nav_speed          <def[n].navigator.speed||No_Nav_Speed>
        - define npc_nav_range          <def[n].navigator.range||No_Nav_Range>
        - define npc_nav_attack_range   <def[n].navigator.attack_range||No_Nav_Attack_Range>
        - define npc_nav_attak_strat    <def[n].navigator.attack_stratagey||No_Nav_Attack_Stratagey>
        - define npc_nav_speed_modifier <def[n].navigator.speed_modifier||No_Nav_Speed_Modifier>
        - define npc_nav_base_speed     <def[n].navigator.base_speed||No_Nav_Base_Speed>
        - define npc_nav_avoid_water    <def[n].navigator.avoid_water||Dose_Not_Avoid_Water>
        - define npc_nav_base_speed     <def[n].navigator||>
        
        
        - define npc_has_assignment     <def[n].has_script||No_Script_Assignment>
        - define npc_script             <def[n].script||No_Attached_Script>
        - define npc_script_erroring    <tern[<el@<def[n].script>.is[==].to[<def[skript]>]>]:<def[n].script>_Caused_The_Error||The_Npc_Script_Did_Not_Cause_The_Error>
        
        - define npc_flags              <def[n].list_flags.as_string||No_Flags>
        - define npc_engaged            <def[n].is_engaged||Not_Engaged>
        - define npc_ <def[n].||>
        - define npc_ <def[n].||>
        - define npc_ <def[n].||>
        - define npc_ <def[n].||>
        - define npc_ <def[n].||>
        - define npc_ <def[n].||>
        - define npc_anchors            <def[n].anchor.list.as_string||No_Anchors>
        - define npc_traits             <def[n].traits.as_string||No_Traits>
        - define npc_inventory          <def[n].inventory.list_contents.as_string||No_Inventory>
        - define nearby_npcs            <def[n].location.find.npcs.within[25]>
        - define npc_debug "
        
        "
        } else {
        - define npc_debug "There was no npc associated with this queue<&nl>"
        }
    
    - if <def[queue].player||none> != none {
        - define p                      <def[queue].player>
        - define player_name            <def[p].name||none>
        - define player_display_name    <def[p].name.display||none>
        - define player_list_name       <def[p].name.list||none>
        - define player_entity_id       <def[p].eid||none>
        - define player_save_id         <def[p].save_name||none>
        - define player_prefix          <def[p].prefix||none>
        - define player_selected_npc    <def[p].selected_npc||none>
        
        - define player_is_op           <def[p].is_op||none>
        - define player_location        <def[p].location.simple||none>
        - define player_last_chats      <def[p].chat_history_list||none>
        
        - define player_target          <def[p].target||none>
        - define player_open_inventory  <def[p].open_inventory||none>
        - define player_item_cursor_on  <def[p].item_on_cursor||none>
        
        - define player_money           <def[p].money||none>
        - define player_flags           "<def[p].list_flags.alphabetical.space_separated.replace[ ].with[<&nl>]||none>"
        - define player_fall_distance   <def[p].fall_distance||none>
        
        - define player_debug_          <def[p].debug||none>
        
        - define player_debug "
        player_prefix<&co>                     <def[player_prefix]><&nl>
        player_name<&co>                    <def[player_name]><&nl>
        player_list_name<&co>            <def[player_list_name]><&nl>
        player_display_name<&co>    <def[player_display_name]><&nl>
        player_location<&co>                <def[player_location]><&nl>
        player_entity_id<&co>               <def[player_entity_id]><&nl>
        player_save_id<&co>                <def[player_save_id]><&nl>
        player_is_op?                  <def[player_is_op]><&nl>
        player_debug<&co>                   <def[player_debug_]><&nl>
        <&nl>#<&nl>
        player_selected_npc<&co>      <def[player_selected_npc]><&nl>
        player_target<&co>                    <def[player_target]><&nl>
        player_item_cursor_on<&co>  <def[player_item_cursor_on]><&nl>
        <&nl>#<&nl>
        player_fall_distance<&co>      <def[player_fall_distance]><&nl>
        player_last_chats<&co>           <def[player_last_chats]><&nl>
        player_open_inventory<&co>  <def[player_open_inventory]><&nl>
        <&nl>#<&nl>
        <&nl>#<&nl>
        "
        } else {
        - define player_debug "There was no player associated with this queue<&nl>"
        }
        #player_flags:       <&nl><def[player_flags]><&nl>

    #The announcement phase
    - announce "
        <gold>__________ Start Debug ___________________________<&nl>#<&nl>#<&nl>#<&nl>
        <gold>                      <def[time]><&nl>
        
        <red>The error message is as follows:<&nl>
        <def[error_message]><&nl>
        <blue><queue.stats><&nl>
        
        <red>~~~~~ <green>Queue Debug<reset> <red>~~~~~<&nl>
        <def[queue_debug]>
        
        <red>~~~~~ <green>Script Debug<reset> <red>~~~~~<&nl>
        <def[script_debug]>
        
        <red>~~~~~ <green>Player Debug<reset> <red>~~~~~<&nl>
        <def[player_debug]>
        
        <red>~~~~~ <green>Npc Debug<reset> <red>~~~~~<&nl>
        <def[npc_debug]>
        
        <gold>__________ End Debug ___________________________
        " to_console
#